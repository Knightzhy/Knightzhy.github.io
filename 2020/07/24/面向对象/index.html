<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>面向对象 | Knight的小屋子</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="面向对象三大特性封装概念：隐藏实现细节，对外提供接口。 作用：高内聚低耦合，提升代码复用性；安全性；易维护。 实现方式：访问控制符public private protected。 继承概念：子类获得父类的方法和属性。 作用：代码复用，多态的前提 实现方式：单继承，多继承。 多态概念：同一种事物有多种形态。例如狗，可以有不同的品种。 作用：可以不考虑实例的类型而使用实例，提升了灵活性和可扩展的能力">
<meta property="og:type" content="article">
<meta property="og:title" content="面向对象">
<meta property="og:url" content="http://yoursite.com/2020/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Knight的小屋子">
<meta property="og:description" content="面向对象三大特性封装概念：隐藏实现细节，对外提供接口。 作用：高内聚低耦合，提升代码复用性；安全性；易维护。 实现方式：访问控制符public private protected。 继承概念：子类获得父类的方法和属性。 作用：代码复用，多态的前提 实现方式：单继承，多继承。 多态概念：同一种事物有多种形态。例如狗，可以有不同的品种。 作用：可以不考虑实例的类型而使用实例，提升了灵活性和可扩展的能力">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-24T09:27:03.000Z">
<meta property="article:modified_time" content="2020-07-20T16:37:46.629Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Knight的小屋子" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Knight的小屋子</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-面向对象" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time datetime="2020-07-24T09:27:03.000Z" itemprop="datePublished">2020-07-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      面向对象
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>概念：隐藏实现细节，对外提供接口。</p>
<p>作用：高内聚低耦合，提升代码复用性；安全性；易维护。</p>
<p>实现方式：访问控制符public private protected。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>概念：子类获得父类的方法和属性。</p>
<p>作用：代码复用，多态的前提</p>
<p>实现方式：单继承，多继承。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>概念：同一种事物有多种形态。例如狗，可以有不同的品种。</p>
<p>作用：可以不考虑实例的类型而使用实例，提升了灵活性和可扩展的能力。</p>
<p>实现方式：继承和虚函数表，在使用时，父类指针指向子类对象。</p>
<h1 id="重载，重写，隐藏"><a href="#重载，重写，隐藏" class="headerlink" title="重载，重写，隐藏"></a>重载，重写，隐藏</h1><table>
<thead>
<tr>
<th align="right">类别</th>
<th align="right">作用域</th>
<th align="right">函数名</th>
<th align="right">参数列表</th>
<th align="right">返回值</th>
<th align="right">是否有virtual修饰</th>
</tr>
</thead>
<tbody><tr>
<td align="right">重载</td>
<td align="right">同一作用域</td>
<td align="right">相同</td>
<td align="right">不同</td>
<td align="right">无要求</td>
<td align="right">无要求</td>
</tr>
<tr>
<td align="right">重写（覆盖）</td>
<td align="right">不同作用域（父与子）</td>
<td align="right">相同</td>
<td align="right">相同</td>
<td align="right">相同</td>
<td align="right">父类必须有virtual修饰</td>
</tr>
<tr>
<td align="right">隐藏（重定义）</td>
<td align="right">不同作用域（父与子）</td>
<td align="right">相同</td>
<td align="right">不同</td>
<td align="right">无要求</td>
<td align="right">父类带virtual修饰</td>
</tr>
<tr>
<td align="right">隐藏（重定义）</td>
<td align="right">不同作用域（父与子）</td>
<td align="right">相同</td>
<td align="right">无要求</td>
<td align="right">无要求</td>
<td align="right">父类不带virtual修饰</td>
</tr>
</tbody></table>
<h2 id="重载overload"><a href="#重载overload" class="headerlink" title="重载overload"></a>重载overload</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">  void test(int i);</span><br><span class="line">  void test(double i);&#x2F;&#x2F;overload</span><br><span class="line">  void test(int i, double j);&#x2F;&#x2F;overload</span><br><span class="line">  void test(double i, int j);&#x2F;&#x2F;overload</span><br><span class="line">  int test(int i);         &#x2F;&#x2F;错误，非重载。注意重载不关心函数返回类型。</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>重载是在同一作用域内，同名函数的参数列表不同，根据参数列表判断使用哪个函数。</p>
<h2 id="重写override"><a href="#重写override" class="headerlink" title="重写override"></a>重写override</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 3重写了1</span><br><span class="line">&#x2F;&#x2F; 4重写了2（协变情况）</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Swap(int* a, int* b); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">    virtual A* get(char* str);         &#x2F;&#x2F;2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void Swap(int* a, int* b); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">    virtual B* get(char* str);         &#x2F;&#x2F;4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>协变情况：在C++中，只要原来的返回类型是基类类型的指针或引用，新的返回值类型是派生类的指针或引用，覆盖的方法就可以改变返回类型，这样的返回类型称为协变返回类型。</p>
<h2 id="隐藏redefining"><a href="#隐藏redefining" class="headerlink" title="隐藏redefining"></a>隐藏redefining</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;派生类中3隐藏了1</span><br><span class="line">&#x2F;&#x2F;派生类中4隐藏了2</span><br><span class="line">class A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Swap(int* a, int* b); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">    A* get(char* str);         &#x2F;&#x2F;2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class B : public A</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    void Swap(int* a); &#x2F;&#x2F;3</span><br><span class="line"></span><br><span class="line">    B* get(char* str);         &#x2F;&#x2F;4</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>派生类的函数屏蔽了基类的同名函数，对参数列表和返回无要求。如果基类的函数带virtual，那么参数列表相同时就是重写，参数列表不同时是隐藏；如果基类的函数不带virtual修饰，那么不论参数列表是否相同，都是隐藏。</p>
<h1 id="静态多态，动态多态"><a href="#静态多态，动态多态" class="headerlink" title="静态多态，动态多态"></a>静态多态，动态多态</h1><h2 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h2><p>也叫编译器多态，根据参数确定使用的函数。有两种实现方式，函数重载和函数模板。</p>
<h2 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h2><p>也叫运行时多态，在运行时根据运行实例确定使用的函数。实现方式是虚函数。</p>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>成员函数带virtual修饰。用来实现多态，运行时确定使用的函数。</p>
<p>类的构造函数和静态成员函数不可以定义为虚函数。只有类的析构函数和非静态成员函数可以被定义为虚函数。因为构造函数和静态成员函数不可以被继承。</p>
<p>虚析构函数，用来解决基类指针指向子类对象时，用指针销毁对象，如果析构函数没有设置为虚函数，则在销毁对象时只会执行基类的析构函数。</p>
<p>纯虚函数，虚函数=0，不含定义。</p>
<p>抽象类，含有纯虚函数的类。</p>
<h1 id="重载二义性"><a href="#重载二义性" class="headerlink" title="重载二义性"></a>重载二义性</h1><p>函数重载主要是一个匹配问题，分为精准匹配，提升匹配和类型转换匹配三种。</p>
<p>精准匹配：参数完全匹配。</p>
<p>提升匹配：参数不能完全匹配，参数的类型提升以后存在唯一的完全匹配的函数。这种提升是编译器的一个特性，比如bool 到 int、char到int、short 到int，float到double （也叫隐式转换）。</p>
<p>类型转换匹配：参数不能完全匹配，但是参数的类型转换后匹配到重载函数。类型转换匹配也叫标准转换匹配常见的有int 到double、double到int、double到long double、int到unsigned int。</p>
<p>二义性：当参数类型转换后，可以匹配到多个重载函数时。</p>
<h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><p>public：本类，子类，类外可以访问</p>
<p>protected：本类，子类可以访问</p>
<p>private：本类可以访问</p>
<h1 id="继承修饰"><a href="#继承修饰" class="headerlink" title="继承修饰"></a>继承修饰</h1><p>子类继承父类时，用public,protected,prrivate修饰</p>
<p>public:子类继承父类的public,protected成员及成员函数，继承的访问修饰符不变。</p>
<p>protected:子类继承父类的public,protected成员及成员函数，继承的访问修饰符都变成protected</p>
<p>private:子类继承父类的public.protected成员及成员函数，继承的访问修饰符都变成private</p>
<h1 id="虚继承，虚基类，多重继承"><a href="#虚继承，虚基类，多重继承" class="headerlink" title="虚继承，虚基类，多重继承"></a>虚继承，虚基类，多重继承</h1><p>多重继承：继承与多个基类。</p>
<p>虚继承和虚基类，是为了解决多重继承时发生菱形继承，菱形继承会存在数据冗余，同时访问数据复杂。虚基类，即相同的父类只会保留一份。虚继承，继承时使用virtual修饰。</p>
<h1 id="const"><a href="#const" class="headerlink" title="const"></a>const</h1><p>const，在成员函数后加const，表示常函数。常函数不可以修改成员变量，但是如果成员变量使用mutable关键字修饰，常函数就可以修改这个成员变量。</p>
<p>const，在声明类的对象前加const，表示常对象。常对象只能调用常函数。</p>
<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><p>static成员函数只能调用static成员变量或者static成员函数。</p>
<p>static成员变量的定义在类外定义。</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>[1] 重载、重写和隐藏三者的区别  (<a href="https://www.cnblogs.com/evenleee/p/10933793.html" target="_blank" rel="noopener">https://www.cnblogs.com/evenleee/p/10933793.html</a>)</p>
<p>[2] C++中重载、重写（覆盖）和隐藏的区别 (<a href="https://www.cnblogs.com/zhangjxblog/p/8723291.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangjxblog/p/8723291.html</a>)</p>
<p>[3]使用虚基类和虚继承代替多重继承(<a href="https://blog.csdn.net/weixin_41528527/article/details/107174292" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41528527/article/details/107174292</a>)</p>
<p>[4]C++中对C的扩展学习新增内容———面向对象（继承）多继承和虚继承(<a href="https://www.cnblogs.com/yyslif/p/11758754.html" target="_blank" rel="noopener">https://www.cnblogs.com/yyslif/p/11758754.html</a>)</p>
<p>[5]C++之const类成员变量，const成员函数(<a href="https://www.cnblogs.com/cthon/p/9178701.html" target="_blank" rel="noopener">https://www.cnblogs.com/cthon/p/9178701.html</a>)</p>
<p>[6]面向对象——(static关键字)(<a href="https://blog.csdn.net/zhanshixiang/article/details/81162302" target="_blank" rel="noopener">https://blog.csdn.net/zhanshixiang/article/details/81162302</a>)</p>
<p>[7]函数重载导致的二义性 (<a href="https://blog.csdn.net/yddj5/article/details/53815387" target="_blank" rel="noopener">https://blog.csdn.net/yddj5/article/details/53815387</a>)</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="ckcuqeaz7000058oi0bdf59g4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2020/01/23/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/24/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/">面向对象</a>
          </li>
        
          <li>
            <a href="/2020/01/23/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>